class Translator {
        private string apiKey;
        private string model;
        json_object availableLanguages;

	void addLanguage(const string &in nameLang, const string &in flagLang) {
		availableLanguages[nameLang] = flagLang;
	}

	void init(int list1, int list2) {
		string languagesList = "Afrikaans=af\nAlbanian=sq\nAmharic=am\nArabic=ar\nArmenian=hy\nAzerbaijani=az\nBasque=eu\nBelarusian=be\nBengali=bn\nBosnian=bs\nBulgarian=bg\nCatalan=ca\nCebuano=ceb\nChinese (simplified)=zh-CN\nChinese (traditional)=zh-TW\nCorsican=co\nCroatian=hr\nCzech=cs\nDanish=da\nDutch=nl\nEnglish=en\nEsperanto=eo\nEstonian=et\nFinnish=fi\nFrench=fr\nFrisian=fy\nGalician=gl\nGeorgian=ka\nGerman=de\nGreek=el\nGujarati=gu\nHaitian Creole=ht\nHausa=ha\nHawaiian=haw\nHebrew=he\nHindi=hi\nHmong=hmn\nHungarian=hu\nIcelandic=is\nIgbo=ig\nIndonesian=id\nIrish=ga\nItalian=it\nJapanese=ja\nJavanese=jw\nKannada=kn\nKazakh=kk\nKhmer=km\nKorean=ko\nKurdish=ku\nKyrgyz=ky\nLao=lo\nLatin=la\nLatvian=lv\nLithuanian=lt\nLuxembourgish=lb\nMacedonian=mk\nMalagasy=mg\nMalay=ms\nMalayalam=ml\nMaltese=mt\nMaori=mi\nMarathi=mr\nMongolian=mn\nMyanmar (Burmese)=my\nNepali=ne\nNorwegian=no\nNyanja (Chichewa)=ny\nPashto=ps\nPersian=fa\nPolish=pl\nPortuguese=pt-BR\nPunjabi=pa\nRomanian=ro\nRussian=ru\nSamoan=sm\nScots Gaelic=gd\nSerbian=sr\nSesotho=st\nShona=sn\nSindhi=sd\nSinhala (Sinhalese)=si\nSlovak=sk\nSlovenian=sl\nSomali=so\nSpanish=es\nSundanese=su\nSwahili=sw\nSwedish=sv\nTagalog (Filipino)=tl\nTajik=tg\nTamil=ta\nTelugu=te\nThai=th\nTurkish=tr\nUkrainian=uk\nUrdu=ur\nUzbek=uz\nVietnamese=vi\nWelsh=cy\nXhosa=xh\nYiddish=yi\nYoruba=yo\nZulu=zu";
		string[] languages = languagesList.split("\n", false);
		for(int i = 0; i < languages.length(); i++) {
			string[] parsedLang = languages[i].split("=", false);
			this.addLanguage(parsedLang[0], parsedLang[1]);
			form.add_list_item(list1, parsedLang[0]);
			form.add_list_item(list2, parsedLang[0]);
		}
		this.addLanguage("Automatic", "auto");
		form.add_list_item(list1, "Automatic");
	}

        void setApiKey(const string &in key) {
            this.apiKey = key;
        }

        string getApiKey() {
            return this.apiKey;
        }

        void setModel(const string &in modelName) {
            this.model = modelName;
        }
        string getModel() {
            return this.model.length() > 0 ? this.model : "gemini-1.5-flash";
        }

        private string buildApiUrl() {
            return "https://generativelanguage.googleapis.com/v1beta/models/" + this.getModel() + ":generateContent?key=" + this.apiKey;
        }

        private string escapeJsonString(const string &in text) {
            string escaped = text;
            
            escaped.replace_this("\\", "\\\\", true);
            
            escaped.replace_this("\"", "\\\"");
            
            escaped.replace_this("\n", "\\n");
            escaped.replace_this("\r", "\\r");
            escaped.replace_this("\t", "\\t");
            escaped.replace_this("\b", "\\b");
            escaped.replace_this("\f", "\\f");
            
            return escaped;
        }

        private string buildJsonPayload(const string &in text) {
            string escapedText = this.escapeJsonString(text);
            
            string body = "{\"contents\":[{\"parts\":[{\"text\":\"" + escapedText + "\"}]}]}";
            
            return body;
        }

        string detectLanguageAndTranslate(const string &in text, const string &in sourceLang, const string &in targetLang) {
            string url = this.buildApiUrl();
            
            string prompt = "You are a language detection and translation expert. Analyze the provided text and:\n";
            prompt += "1. Detect the language of the text\n";
            prompt += "2. Compare it with the configured source language: '" + sourceLang + "' and target language: '" + targetLang + "'\n";
            prompt += "3. If the detected language matches the TARGET language ('" + targetLang + "'), translate FROM target TO source\n";
            prompt += "4. If the detected language matches the SOURCE language ('" + sourceLang + "') or is different from both, translate FROM source TO target\n";
            prompt += "5. For 'Automatic' source language, always detect and translate to the target language\n\n";
            prompt += "CRITICAL: Provide ONLY ONE clean translation without multiple options, prefixes, or formatting.\n";
            prompt += "RESPONSE FORMAT (respond ONLY with this format):\n";
            prompt += "DIRECTION: [source_to_target|target_to_source]\n";
            prompt += "TRANSLATION: [the actual translation here - SINGLE CLEAN TRANSLATION ONLY]\n\n";
            prompt += "DO NOT include multiple translation options, prefixes, or any ### delimiters.\n";
            prompt += "Text to analyze: \"" + text + "\"";

            string body = this.buildJsonPayload(prompt);
            
            string result = requestURL(url, body);
            
            try {
                json_object@ response = parse_json(result);
                if (response.exists("error")) {
                    json_object@ error = response["error"];
                    string errorMessage = "API Error: ";
                    if (error.exists("message")) {
                        errorMessage += error["message"];
                    } else {
                        errorMessage += "Unknown error";
                    }
                    return "Error: " + errorMessage;
                }
                
                json_array@ candidates = response["candidates"];
                
                if (candidates is null || candidates.length() == 0) {
                    return "Error: Invalid API response for language detection.";
                }
                
                json_object@ firstCandidate = candidates[0];
                json_object@ content = firstCandidate["content"];
                json_array@ parts = content["parts"];
                
                if (parts is null || parts.length() == 0) {
                    return "Error: Invalid API response for language detection.";
                }
                
                json_object@ firstPart = parts[0];
                string analysisResult = firstPart["text"];
                
                string translation = "";
                if (analysisResult.find("TRANSLATION:") != -1) {
                    int translationStart = analysisResult.find("TRANSLATION:") + 12;
                    translation = analysisResult.substr(translationStart).trim_whitespace();
                }
                
                string direction = "normal";
                if (analysisResult.find("DIRECTION: target_to_source") != -1) {
                    direction = "reversa";
                }
                
                return direction + "|" + translation;
                
            } catch {
                return "fallback|" + this.translate(sourceLang, targetLang, text);
            }
        }

	string translate(const string &in originalLang, const string &in destinationLang, const string&in text) {
		string url = this.buildApiUrl();

		string fromLang = (this.availableLanguages[originalLang] == "auto") ? "the automatically detected language" : "'" + originalLang + "'";
		string toLang = "'" + destinationLang + "'";
		string userLang = getUserLanguage();

		string prompt = "You are an expert translator. Your task is to translate the provided text to the " + toLang + " language.\n";
		prompt += "The original language of the text is " + fromLang + ".\n";
		prompt += "CRITICAL INSTRUCTIONS:\n";
		prompt += "1. ALL translation results must be in " + toLang + " language only.\n";
		prompt += "2. The TYPE descriptions must be in " + userLang + " language.\n";
		prompt += "3. The actual translated text must be in " + toLang + " language.\n";
		prompt += "4. CRITICAL: Use EXACT format ###TYPE### TRANSLATION_TEXT\n";
		prompt += "5. Provide multiple translation options when applicable (formal, informal, literal, contextual, etc).\n";
		prompt += "6. For each translation, use this EXACT format:\n";
		prompt += "   ###TYPE### translation_text\n";
		prompt += "   Where:\n";
		prompt += "   - TYPE: description in " + userLang + " (like 'tradução formal', 'tradução informal', etc.)\n";
		prompt += "   - translation_text: the actual translation in " + toLang + " ONLY\n";
		
		// Add specific examples based on user language
		if (userLang.find("Indonesian") != -1) {
			prompt += "7. Example for Indonesian user translating to English:\n";
			prompt += "   ###terjemahan formal### Good morning, how are you?\n";
			prompt += "   ###terjemahan santai### Hey, how's it going?\n";
		} else if (userLang.find("Portuguese") != -1 || userLang.find("Português") != -1) {
			prompt += "7. Example for Portuguese user translating to English:\n";
			prompt += "   ###tradução formal### Good morning, how are you?\n";
			prompt += "   ###tradução informal### Hey, how's it going?\n";
		} else {
			prompt += "7. Example:\n";
			prompt += "   ###formal translation### [translated text in target language]\n";
			prompt += "   ###informal translation### [translated text in target language]\n";
		}
		
		prompt += "8. IMPORTANT: Do NOT mix prefixes like 'tradução formal:' with ### delimiters.\n";
		prompt += "9. IMPORTANT: Each translation must start with ### and end with the translated text only.\n";
		prompt += "10. Use ||| to separate multiple translation groups if needed.\n";
		prompt += "11. Do not include any other explanations outside the format specified.\n\n";
		prompt += "Text to translate:\n---\n" + text + "\n---";

		string body = this.buildJsonPayload(prompt);
		
		// alert("Debug JSON - Translate", body);
		string result = requestURL(url, body);

		try {
			json_object@ response = parse_json(result);
			
			// Verificar se há erro na resposta da API
			if (response.exists("error")) {
				json_object@ error = response["error"];
				string errorMessage = "API Error: ";
				if (error.exists("message")) {
					errorMessage += error["message"];
				} else {
					errorMessage += "Unknown error";
				}
				alert("Gemini API Error", errorMessage);
				return "Error: " + errorMessage;
			}
			
			json_array@ candidates = response["candidates"];

			if (candidates is null || candidates.length() == 0) {
				 alert("Gemini API Error", "The API response does not contain 'candidates'. Response received: " + result);
				 return "Error: Invalid API response.";
			}

			json_object@ firstCandidate = candidates[0];
			json_object@ content = firstCandidate["content"];
			json_array@ parts = content["parts"];

			if (parts is null || parts.length() == 0) {
				alert("Gemini API Error", "The API response does not contain 'parts'.");
				return "Error: Invalid API response.";
			}

			json_object@ firstPart = parts[0];
			string translatedText = firstPart["text"];

			return translatedText;

		} catch {
			alert("Translation Error", "Failed to process Gemini API response.\\n" + get_exception_info() + "\\nResponse received:\\n" + result);
			return "Translation error.";
		}

		return "Unknown translation error.";
	}
}
